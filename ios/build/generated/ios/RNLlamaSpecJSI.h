/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeRNLlamaNativeCompletionParams

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15, typename P16, typename P17, typename P18, typename P19, typename P20, typename P21, typename P22, typename P23, typename P24, typename P25, typename P26, typename P27, typename P28, typename P29, typename P30, typename P31, typename P32, typename P33, typename P34>
struct NativeRNLlamaNativeCompletionParams {
  P0 prompt;
  P1 n_threads;
  P2 json_schema;
  P3 grammar;
  P4 grammar_lazy;
  P5 grammar_triggers;
  P6 preserved_tokens;
  P7 chat_format;
  P8 stop;
  P9 n_predict;
  P10 n_probs;
  P11 top_k;
  P12 top_p;
  P13 min_p;
  P14 xtc_probability;
  P15 xtc_threshold;
  P16 typical_p;
  P17 temperature;
  P18 penalty_last_n;
  P19 penalty_repeat;
  P20 penalty_freq;
  P21 penalty_present;
  P22 mirostat;
  P23 mirostat_tau;
  P24 mirostat_eta;
  P25 dry_multiplier;
  P26 dry_base;
  P27 dry_allowed_length;
  P28 dry_penalty_last_n;
  P29 dry_sequence_breakers;
  P30 top_n_sigma;
  P31 ignore_eos;
  P32 logit_bias;
  P33 seed;
  P34 emit_partial_completion;
  bool operator==(const NativeRNLlamaNativeCompletionParams &other) const {
    return prompt == other.prompt && n_threads == other.n_threads && json_schema == other.json_schema && grammar == other.grammar && grammar_lazy == other.grammar_lazy && grammar_triggers == other.grammar_triggers && preserved_tokens == other.preserved_tokens && chat_format == other.chat_format && stop == other.stop && n_predict == other.n_predict && n_probs == other.n_probs && top_k == other.top_k && top_p == other.top_p && min_p == other.min_p && xtc_probability == other.xtc_probability && xtc_threshold == other.xtc_threshold && typical_p == other.typical_p && temperature == other.temperature && penalty_last_n == other.penalty_last_n && penalty_repeat == other.penalty_repeat && penalty_freq == other.penalty_freq && penalty_present == other.penalty_present && mirostat == other.mirostat && mirostat_tau == other.mirostat_tau && mirostat_eta == other.mirostat_eta && dry_multiplier == other.dry_multiplier && dry_base == other.dry_base && dry_allowed_length == other.dry_allowed_length && dry_penalty_last_n == other.dry_penalty_last_n && dry_sequence_breakers == other.dry_sequence_breakers && top_n_sigma == other.top_n_sigma && ignore_eos == other.ignore_eos && logit_bias == other.logit_bias && seed == other.seed && emit_partial_completion == other.emit_partial_completion;
  }
};

template <typename T>
struct NativeRNLlamaNativeCompletionParamsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.prompt)>(rt, value.getProperty(rt, "prompt"), jsInvoker),
      bridging::fromJs<decltype(types.n_threads)>(rt, value.getProperty(rt, "n_threads"), jsInvoker),
      bridging::fromJs<decltype(types.json_schema)>(rt, value.getProperty(rt, "json_schema"), jsInvoker),
      bridging::fromJs<decltype(types.grammar)>(rt, value.getProperty(rt, "grammar"), jsInvoker),
      bridging::fromJs<decltype(types.grammar_lazy)>(rt, value.getProperty(rt, "grammar_lazy"), jsInvoker),
      bridging::fromJs<decltype(types.grammar_triggers)>(rt, value.getProperty(rt, "grammar_triggers"), jsInvoker),
      bridging::fromJs<decltype(types.preserved_tokens)>(rt, value.getProperty(rt, "preserved_tokens"), jsInvoker),
      bridging::fromJs<decltype(types.chat_format)>(rt, value.getProperty(rt, "chat_format"), jsInvoker),
      bridging::fromJs<decltype(types.stop)>(rt, value.getProperty(rt, "stop"), jsInvoker),
      bridging::fromJs<decltype(types.n_predict)>(rt, value.getProperty(rt, "n_predict"), jsInvoker),
      bridging::fromJs<decltype(types.n_probs)>(rt, value.getProperty(rt, "n_probs"), jsInvoker),
      bridging::fromJs<decltype(types.top_k)>(rt, value.getProperty(rt, "top_k"), jsInvoker),
      bridging::fromJs<decltype(types.top_p)>(rt, value.getProperty(rt, "top_p"), jsInvoker),
      bridging::fromJs<decltype(types.min_p)>(rt, value.getProperty(rt, "min_p"), jsInvoker),
      bridging::fromJs<decltype(types.xtc_probability)>(rt, value.getProperty(rt, "xtc_probability"), jsInvoker),
      bridging::fromJs<decltype(types.xtc_threshold)>(rt, value.getProperty(rt, "xtc_threshold"), jsInvoker),
      bridging::fromJs<decltype(types.typical_p)>(rt, value.getProperty(rt, "typical_p"), jsInvoker),
      bridging::fromJs<decltype(types.temperature)>(rt, value.getProperty(rt, "temperature"), jsInvoker),
      bridging::fromJs<decltype(types.penalty_last_n)>(rt, value.getProperty(rt, "penalty_last_n"), jsInvoker),
      bridging::fromJs<decltype(types.penalty_repeat)>(rt, value.getProperty(rt, "penalty_repeat"), jsInvoker),
      bridging::fromJs<decltype(types.penalty_freq)>(rt, value.getProperty(rt, "penalty_freq"), jsInvoker),
      bridging::fromJs<decltype(types.penalty_present)>(rt, value.getProperty(rt, "penalty_present"), jsInvoker),
      bridging::fromJs<decltype(types.mirostat)>(rt, value.getProperty(rt, "mirostat"), jsInvoker),
      bridging::fromJs<decltype(types.mirostat_tau)>(rt, value.getProperty(rt, "mirostat_tau"), jsInvoker),
      bridging::fromJs<decltype(types.mirostat_eta)>(rt, value.getProperty(rt, "mirostat_eta"), jsInvoker),
      bridging::fromJs<decltype(types.dry_multiplier)>(rt, value.getProperty(rt, "dry_multiplier"), jsInvoker),
      bridging::fromJs<decltype(types.dry_base)>(rt, value.getProperty(rt, "dry_base"), jsInvoker),
      bridging::fromJs<decltype(types.dry_allowed_length)>(rt, value.getProperty(rt, "dry_allowed_length"), jsInvoker),
      bridging::fromJs<decltype(types.dry_penalty_last_n)>(rt, value.getProperty(rt, "dry_penalty_last_n"), jsInvoker),
      bridging::fromJs<decltype(types.dry_sequence_breakers)>(rt, value.getProperty(rt, "dry_sequence_breakers"), jsInvoker),
      bridging::fromJs<decltype(types.top_n_sigma)>(rt, value.getProperty(rt, "top_n_sigma"), jsInvoker),
      bridging::fromJs<decltype(types.ignore_eos)>(rt, value.getProperty(rt, "ignore_eos"), jsInvoker),
      bridging::fromJs<decltype(types.logit_bias)>(rt, value.getProperty(rt, "logit_bias"), jsInvoker),
      bridging::fromJs<decltype(types.seed)>(rt, value.getProperty(rt, "seed"), jsInvoker),
      bridging::fromJs<decltype(types.emit_partial_completion)>(rt, value.getProperty(rt, "emit_partial_completion"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String promptToJs(jsi::Runtime &rt, decltype(types.prompt) value) {
    return bridging::toJs(rt, value);
  }

  static double n_threadsToJs(jsi::Runtime &rt, decltype(types.n_threads) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String json_schemaToJs(jsi::Runtime &rt, decltype(types.json_schema) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String grammarToJs(jsi::Runtime &rt, decltype(types.grammar) value) {
    return bridging::toJs(rt, value);
  }

  static bool grammar_lazyToJs(jsi::Runtime &rt, decltype(types.grammar_lazy) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array grammar_triggersToJs(jsi::Runtime &rt, decltype(types.grammar_triggers) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array preserved_tokensToJs(jsi::Runtime &rt, decltype(types.preserved_tokens) value) {
    return bridging::toJs(rt, value);
  }

  static double chat_formatToJs(jsi::Runtime &rt, decltype(types.chat_format) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array stopToJs(jsi::Runtime &rt, decltype(types.stop) value) {
    return bridging::toJs(rt, value);
  }

  static double n_predictToJs(jsi::Runtime &rt, decltype(types.n_predict) value) {
    return bridging::toJs(rt, value);
  }

  static double n_probsToJs(jsi::Runtime &rt, decltype(types.n_probs) value) {
    return bridging::toJs(rt, value);
  }

  static double top_kToJs(jsi::Runtime &rt, decltype(types.top_k) value) {
    return bridging::toJs(rt, value);
  }

  static double top_pToJs(jsi::Runtime &rt, decltype(types.top_p) value) {
    return bridging::toJs(rt, value);
  }

  static double min_pToJs(jsi::Runtime &rt, decltype(types.min_p) value) {
    return bridging::toJs(rt, value);
  }

  static double xtc_probabilityToJs(jsi::Runtime &rt, decltype(types.xtc_probability) value) {
    return bridging::toJs(rt, value);
  }

  static double xtc_thresholdToJs(jsi::Runtime &rt, decltype(types.xtc_threshold) value) {
    return bridging::toJs(rt, value);
  }

  static double typical_pToJs(jsi::Runtime &rt, decltype(types.typical_p) value) {
    return bridging::toJs(rt, value);
  }

  static double temperatureToJs(jsi::Runtime &rt, decltype(types.temperature) value) {
    return bridging::toJs(rt, value);
  }

  static double penalty_last_nToJs(jsi::Runtime &rt, decltype(types.penalty_last_n) value) {
    return bridging::toJs(rt, value);
  }

  static double penalty_repeatToJs(jsi::Runtime &rt, decltype(types.penalty_repeat) value) {
    return bridging::toJs(rt, value);
  }

  static double penalty_freqToJs(jsi::Runtime &rt, decltype(types.penalty_freq) value) {
    return bridging::toJs(rt, value);
  }

  static double penalty_presentToJs(jsi::Runtime &rt, decltype(types.penalty_present) value) {
    return bridging::toJs(rt, value);
  }

  static double mirostatToJs(jsi::Runtime &rt, decltype(types.mirostat) value) {
    return bridging::toJs(rt, value);
  }

  static double mirostat_tauToJs(jsi::Runtime &rt, decltype(types.mirostat_tau) value) {
    return bridging::toJs(rt, value);
  }

  static double mirostat_etaToJs(jsi::Runtime &rt, decltype(types.mirostat_eta) value) {
    return bridging::toJs(rt, value);
  }

  static double dry_multiplierToJs(jsi::Runtime &rt, decltype(types.dry_multiplier) value) {
    return bridging::toJs(rt, value);
  }

  static double dry_baseToJs(jsi::Runtime &rt, decltype(types.dry_base) value) {
    return bridging::toJs(rt, value);
  }

  static double dry_allowed_lengthToJs(jsi::Runtime &rt, decltype(types.dry_allowed_length) value) {
    return bridging::toJs(rt, value);
  }

  static double dry_penalty_last_nToJs(jsi::Runtime &rt, decltype(types.dry_penalty_last_n) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array dry_sequence_breakersToJs(jsi::Runtime &rt, decltype(types.dry_sequence_breakers) value) {
    return bridging::toJs(rt, value);
  }

  static double top_n_sigmaToJs(jsi::Runtime &rt, decltype(types.top_n_sigma) value) {
    return bridging::toJs(rt, value);
  }

  static bool ignore_eosToJs(jsi::Runtime &rt, decltype(types.ignore_eos) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array logit_biasToJs(jsi::Runtime &rt, decltype(types.logit_bias) value) {
    return bridging::toJs(rt, value);
  }

  static double seedToJs(jsi::Runtime &rt, decltype(types.seed) value) {
    return bridging::toJs(rt, value);
  }

  static bool emit_partial_completionToJs(jsi::Runtime &rt, decltype(types.emit_partial_completion) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "prompt", bridging::toJs(rt, value.prompt, jsInvoker));
    if (value.n_threads) {
      result.setProperty(rt, "n_threads", bridging::toJs(rt, value.n_threads.value(), jsInvoker));
    }
    if (value.json_schema) {
      result.setProperty(rt, "json_schema", bridging::toJs(rt, value.json_schema.value(), jsInvoker));
    }
    if (value.grammar) {
      result.setProperty(rt, "grammar", bridging::toJs(rt, value.grammar.value(), jsInvoker));
    }
    if (value.grammar_lazy) {
      result.setProperty(rt, "grammar_lazy", bridging::toJs(rt, value.grammar_lazy.value(), jsInvoker));
    }
    if (value.grammar_triggers) {
      result.setProperty(rt, "grammar_triggers", bridging::toJs(rt, value.grammar_triggers.value(), jsInvoker));
    }
    if (value.preserved_tokens) {
      result.setProperty(rt, "preserved_tokens", bridging::toJs(rt, value.preserved_tokens.value(), jsInvoker));
    }
    if (value.chat_format) {
      result.setProperty(rt, "chat_format", bridging::toJs(rt, value.chat_format.value(), jsInvoker));
    }
    if (value.stop) {
      result.setProperty(rt, "stop", bridging::toJs(rt, value.stop.value(), jsInvoker));
    }
    if (value.n_predict) {
      result.setProperty(rt, "n_predict", bridging::toJs(rt, value.n_predict.value(), jsInvoker));
    }
    if (value.n_probs) {
      result.setProperty(rt, "n_probs", bridging::toJs(rt, value.n_probs.value(), jsInvoker));
    }
    if (value.top_k) {
      result.setProperty(rt, "top_k", bridging::toJs(rt, value.top_k.value(), jsInvoker));
    }
    if (value.top_p) {
      result.setProperty(rt, "top_p", bridging::toJs(rt, value.top_p.value(), jsInvoker));
    }
    if (value.min_p) {
      result.setProperty(rt, "min_p", bridging::toJs(rt, value.min_p.value(), jsInvoker));
    }
    if (value.xtc_probability) {
      result.setProperty(rt, "xtc_probability", bridging::toJs(rt, value.xtc_probability.value(), jsInvoker));
    }
    if (value.xtc_threshold) {
      result.setProperty(rt, "xtc_threshold", bridging::toJs(rt, value.xtc_threshold.value(), jsInvoker));
    }
    if (value.typical_p) {
      result.setProperty(rt, "typical_p", bridging::toJs(rt, value.typical_p.value(), jsInvoker));
    }
    if (value.temperature) {
      result.setProperty(rt, "temperature", bridging::toJs(rt, value.temperature.value(), jsInvoker));
    }
    if (value.penalty_last_n) {
      result.setProperty(rt, "penalty_last_n", bridging::toJs(rt, value.penalty_last_n.value(), jsInvoker));
    }
    if (value.penalty_repeat) {
      result.setProperty(rt, "penalty_repeat", bridging::toJs(rt, value.penalty_repeat.value(), jsInvoker));
    }
    if (value.penalty_freq) {
      result.setProperty(rt, "penalty_freq", bridging::toJs(rt, value.penalty_freq.value(), jsInvoker));
    }
    if (value.penalty_present) {
      result.setProperty(rt, "penalty_present", bridging::toJs(rt, value.penalty_present.value(), jsInvoker));
    }
    if (value.mirostat) {
      result.setProperty(rt, "mirostat", bridging::toJs(rt, value.mirostat.value(), jsInvoker));
    }
    if (value.mirostat_tau) {
      result.setProperty(rt, "mirostat_tau", bridging::toJs(rt, value.mirostat_tau.value(), jsInvoker));
    }
    if (value.mirostat_eta) {
      result.setProperty(rt, "mirostat_eta", bridging::toJs(rt, value.mirostat_eta.value(), jsInvoker));
    }
    if (value.dry_multiplier) {
      result.setProperty(rt, "dry_multiplier", bridging::toJs(rt, value.dry_multiplier.value(), jsInvoker));
    }
    if (value.dry_base) {
      result.setProperty(rt, "dry_base", bridging::toJs(rt, value.dry_base.value(), jsInvoker));
    }
    if (value.dry_allowed_length) {
      result.setProperty(rt, "dry_allowed_length", bridging::toJs(rt, value.dry_allowed_length.value(), jsInvoker));
    }
    if (value.dry_penalty_last_n) {
      result.setProperty(rt, "dry_penalty_last_n", bridging::toJs(rt, value.dry_penalty_last_n.value(), jsInvoker));
    }
    if (value.dry_sequence_breakers) {
      result.setProperty(rt, "dry_sequence_breakers", bridging::toJs(rt, value.dry_sequence_breakers.value(), jsInvoker));
    }
    if (value.top_n_sigma) {
      result.setProperty(rt, "top_n_sigma", bridging::toJs(rt, value.top_n_sigma.value(), jsInvoker));
    }
    if (value.ignore_eos) {
      result.setProperty(rt, "ignore_eos", bridging::toJs(rt, value.ignore_eos.value(), jsInvoker));
    }
    if (value.logit_bias) {
      result.setProperty(rt, "logit_bias", bridging::toJs(rt, value.logit_bias.value(), jsInvoker));
    }
    if (value.seed) {
      result.setProperty(rt, "seed", bridging::toJs(rt, value.seed.value(), jsInvoker));
    }
    result.setProperty(rt, "emit_partial_completion", bridging::toJs(rt, value.emit_partial_completion, jsInvoker));
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeCompletionResult

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13>
struct NativeRNLlamaNativeCompletionResult {
  P0 text;
  P1 reasoning_content;
  P2 tool_calls;
  P3 content;
  P4 tokens_predicted;
  P5 tokens_evaluated;
  P6 truncated;
  P7 stopped_eos;
  P8 stopped_word;
  P9 stopped_limit;
  P10 stopping_word;
  P11 tokens_cached;
  P12 timings;
  P13 completion_probabilities;
  bool operator==(const NativeRNLlamaNativeCompletionResult &other) const {
    return text == other.text && reasoning_content == other.reasoning_content && tool_calls == other.tool_calls && content == other.content && tokens_predicted == other.tokens_predicted && tokens_evaluated == other.tokens_evaluated && truncated == other.truncated && stopped_eos == other.stopped_eos && stopped_word == other.stopped_word && stopped_limit == other.stopped_limit && stopping_word == other.stopping_word && tokens_cached == other.tokens_cached && timings == other.timings && completion_probabilities == other.completion_probabilities;
  }
};

template <typename T>
struct NativeRNLlamaNativeCompletionResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.text)>(rt, value.getProperty(rt, "text"), jsInvoker),
      bridging::fromJs<decltype(types.reasoning_content)>(rt, value.getProperty(rt, "reasoning_content"), jsInvoker),
      bridging::fromJs<decltype(types.tool_calls)>(rt, value.getProperty(rt, "tool_calls"), jsInvoker),
      bridging::fromJs<decltype(types.content)>(rt, value.getProperty(rt, "content"), jsInvoker),
      bridging::fromJs<decltype(types.tokens_predicted)>(rt, value.getProperty(rt, "tokens_predicted"), jsInvoker),
      bridging::fromJs<decltype(types.tokens_evaluated)>(rt, value.getProperty(rt, "tokens_evaluated"), jsInvoker),
      bridging::fromJs<decltype(types.truncated)>(rt, value.getProperty(rt, "truncated"), jsInvoker),
      bridging::fromJs<decltype(types.stopped_eos)>(rt, value.getProperty(rt, "stopped_eos"), jsInvoker),
      bridging::fromJs<decltype(types.stopped_word)>(rt, value.getProperty(rt, "stopped_word"), jsInvoker),
      bridging::fromJs<decltype(types.stopped_limit)>(rt, value.getProperty(rt, "stopped_limit"), jsInvoker),
      bridging::fromJs<decltype(types.stopping_word)>(rt, value.getProperty(rt, "stopping_word"), jsInvoker),
      bridging::fromJs<decltype(types.tokens_cached)>(rt, value.getProperty(rt, "tokens_cached"), jsInvoker),
      bridging::fromJs<decltype(types.timings)>(rt, value.getProperty(rt, "timings"), jsInvoker),
      bridging::fromJs<decltype(types.completion_probabilities)>(rt, value.getProperty(rt, "completion_probabilities"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String textToJs(jsi::Runtime &rt, decltype(types.text) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String reasoning_contentToJs(jsi::Runtime &rt, decltype(types.reasoning_content) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array tool_callsToJs(jsi::Runtime &rt, decltype(types.tool_calls) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String contentToJs(jsi::Runtime &rt, decltype(types.content) value) {
    return bridging::toJs(rt, value);
  }

  static double tokens_predictedToJs(jsi::Runtime &rt, decltype(types.tokens_predicted) value) {
    return bridging::toJs(rt, value);
  }

  static double tokens_evaluatedToJs(jsi::Runtime &rt, decltype(types.tokens_evaluated) value) {
    return bridging::toJs(rt, value);
  }

  static bool truncatedToJs(jsi::Runtime &rt, decltype(types.truncated) value) {
    return bridging::toJs(rt, value);
  }

  static bool stopped_eosToJs(jsi::Runtime &rt, decltype(types.stopped_eos) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String stopped_wordToJs(jsi::Runtime &rt, decltype(types.stopped_word) value) {
    return bridging::toJs(rt, value);
  }

  static double stopped_limitToJs(jsi::Runtime &rt, decltype(types.stopped_limit) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String stopping_wordToJs(jsi::Runtime &rt, decltype(types.stopping_word) value) {
    return bridging::toJs(rt, value);
  }

  static double tokens_cachedToJs(jsi::Runtime &rt, decltype(types.tokens_cached) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object timingsToJs(jsi::Runtime &rt, decltype(types.timings) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array completion_probabilitiesToJs(jsi::Runtime &rt, decltype(types.completion_probabilities) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "text", bridging::toJs(rt, value.text, jsInvoker));
    result.setProperty(rt, "reasoning_content", bridging::toJs(rt, value.reasoning_content, jsInvoker));
    result.setProperty(rt, "tool_calls", bridging::toJs(rt, value.tool_calls, jsInvoker));
    result.setProperty(rt, "content", bridging::toJs(rt, value.content, jsInvoker));
    result.setProperty(rt, "tokens_predicted", bridging::toJs(rt, value.tokens_predicted, jsInvoker));
    result.setProperty(rt, "tokens_evaluated", bridging::toJs(rt, value.tokens_evaluated, jsInvoker));
    result.setProperty(rt, "truncated", bridging::toJs(rt, value.truncated, jsInvoker));
    result.setProperty(rt, "stopped_eos", bridging::toJs(rt, value.stopped_eos, jsInvoker));
    result.setProperty(rt, "stopped_word", bridging::toJs(rt, value.stopped_word, jsInvoker));
    result.setProperty(rt, "stopped_limit", bridging::toJs(rt, value.stopped_limit, jsInvoker));
    result.setProperty(rt, "stopping_word", bridging::toJs(rt, value.stopping_word, jsInvoker));
    result.setProperty(rt, "tokens_cached", bridging::toJs(rt, value.tokens_cached, jsInvoker));
    result.setProperty(rt, "timings", bridging::toJs(rt, value.timings, jsInvoker));
    if (value.completion_probabilities) {
      result.setProperty(rt, "completion_probabilities", bridging::toJs(rt, value.completion_probabilities.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeCompletionResultTimings

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct NativeRNLlamaNativeCompletionResultTimings {
  P0 prompt_n;
  P1 prompt_ms;
  P2 prompt_per_token_ms;
  P3 prompt_per_second;
  P4 predicted_n;
  P5 predicted_ms;
  P6 predicted_per_token_ms;
  P7 predicted_per_second;
  bool operator==(const NativeRNLlamaNativeCompletionResultTimings &other) const {
    return prompt_n == other.prompt_n && prompt_ms == other.prompt_ms && prompt_per_token_ms == other.prompt_per_token_ms && prompt_per_second == other.prompt_per_second && predicted_n == other.predicted_n && predicted_ms == other.predicted_ms && predicted_per_token_ms == other.predicted_per_token_ms && predicted_per_second == other.predicted_per_second;
  }
};

template <typename T>
struct NativeRNLlamaNativeCompletionResultTimingsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.prompt_n)>(rt, value.getProperty(rt, "prompt_n"), jsInvoker),
      bridging::fromJs<decltype(types.prompt_ms)>(rt, value.getProperty(rt, "prompt_ms"), jsInvoker),
      bridging::fromJs<decltype(types.prompt_per_token_ms)>(rt, value.getProperty(rt, "prompt_per_token_ms"), jsInvoker),
      bridging::fromJs<decltype(types.prompt_per_second)>(rt, value.getProperty(rt, "prompt_per_second"), jsInvoker),
      bridging::fromJs<decltype(types.predicted_n)>(rt, value.getProperty(rt, "predicted_n"), jsInvoker),
      bridging::fromJs<decltype(types.predicted_ms)>(rt, value.getProperty(rt, "predicted_ms"), jsInvoker),
      bridging::fromJs<decltype(types.predicted_per_token_ms)>(rt, value.getProperty(rt, "predicted_per_token_ms"), jsInvoker),
      bridging::fromJs<decltype(types.predicted_per_second)>(rt, value.getProperty(rt, "predicted_per_second"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double prompt_nToJs(jsi::Runtime &rt, decltype(types.prompt_n) value) {
    return bridging::toJs(rt, value);
  }

  static double prompt_msToJs(jsi::Runtime &rt, decltype(types.prompt_ms) value) {
    return bridging::toJs(rt, value);
  }

  static double prompt_per_token_msToJs(jsi::Runtime &rt, decltype(types.prompt_per_token_ms) value) {
    return bridging::toJs(rt, value);
  }

  static double prompt_per_secondToJs(jsi::Runtime &rt, decltype(types.prompt_per_second) value) {
    return bridging::toJs(rt, value);
  }

  static double predicted_nToJs(jsi::Runtime &rt, decltype(types.predicted_n) value) {
    return bridging::toJs(rt, value);
  }

  static double predicted_msToJs(jsi::Runtime &rt, decltype(types.predicted_ms) value) {
    return bridging::toJs(rt, value);
  }

  static double predicted_per_token_msToJs(jsi::Runtime &rt, decltype(types.predicted_per_token_ms) value) {
    return bridging::toJs(rt, value);
  }

  static double predicted_per_secondToJs(jsi::Runtime &rt, decltype(types.predicted_per_second) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "prompt_n", bridging::toJs(rt, value.prompt_n, jsInvoker));
    result.setProperty(rt, "prompt_ms", bridging::toJs(rt, value.prompt_ms, jsInvoker));
    result.setProperty(rt, "prompt_per_token_ms", bridging::toJs(rt, value.prompt_per_token_ms, jsInvoker));
    result.setProperty(rt, "prompt_per_second", bridging::toJs(rt, value.prompt_per_second, jsInvoker));
    result.setProperty(rt, "predicted_n", bridging::toJs(rt, value.predicted_n, jsInvoker));
    result.setProperty(rt, "predicted_ms", bridging::toJs(rt, value.predicted_ms, jsInvoker));
    result.setProperty(rt, "predicted_per_token_ms", bridging::toJs(rt, value.predicted_per_token_ms, jsInvoker));
    result.setProperty(rt, "predicted_per_second", bridging::toJs(rt, value.predicted_per_second, jsInvoker));
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeCompletionTokenProb

template <typename P0, typename P1>
struct NativeRNLlamaNativeCompletionTokenProb {
  P0 content;
  P1 probs;
  bool operator==(const NativeRNLlamaNativeCompletionTokenProb &other) const {
    return content == other.content && probs == other.probs;
  }
};

template <typename T>
struct NativeRNLlamaNativeCompletionTokenProbBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.content)>(rt, value.getProperty(rt, "content"), jsInvoker),
      bridging::fromJs<decltype(types.probs)>(rt, value.getProperty(rt, "probs"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String contentToJs(jsi::Runtime &rt, decltype(types.content) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array probsToJs(jsi::Runtime &rt, decltype(types.probs) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "content", bridging::toJs(rt, value.content, jsInvoker));
    result.setProperty(rt, "probs", bridging::toJs(rt, value.probs, jsInvoker));
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeCompletionTokenProbItem

template <typename P0, typename P1>
struct NativeRNLlamaNativeCompletionTokenProbItem {
  P0 tok_str;
  P1 prob;
  bool operator==(const NativeRNLlamaNativeCompletionTokenProbItem &other) const {
    return tok_str == other.tok_str && prob == other.prob;
  }
};

template <typename T>
struct NativeRNLlamaNativeCompletionTokenProbItemBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.tok_str)>(rt, value.getProperty(rt, "tok_str"), jsInvoker),
      bridging::fromJs<decltype(types.prob)>(rt, value.getProperty(rt, "prob"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String tok_strToJs(jsi::Runtime &rt, decltype(types.tok_str) value) {
    return bridging::toJs(rt, value);
  }

  static double probToJs(jsi::Runtime &rt, decltype(types.prob) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "tok_str", bridging::toJs(rt, value.tok_str, jsInvoker));
    result.setProperty(rt, "prob", bridging::toJs(rt, value.prob, jsInvoker));
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeContextParams

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15, typename P16, typename P17, typename P18, typename P19, typename P20, typename P21, typename P22, typename P23, typename P24>
struct NativeRNLlamaNativeContextParams {
  P0 model;
  P1 chat_template;
  P2 reasoning_format;
  P3 is_model_asset;
  P4 use_progress_callback;
  P5 n_ctx;
  P6 n_batch;
  P7 n_ubatch;
  P8 n_threads;
  P9 n_gpu_layers;
  P10 no_gpu_devices;
  P11 flash_attn;
  P12 cache_type_k;
  P13 cache_type_v;
  P14 use_mlock;
  P15 use_mmap;
  P16 vocab_only;
  P17 lora;
  P18 lora_scaled;
  P19 lora_list;
  P20 rope_freq_base;
  P21 rope_freq_scale;
  P22 pooling_type;
  P23 embedding;
  P24 embd_normalize;
  bool operator==(const NativeRNLlamaNativeContextParams &other) const {
    return model == other.model && chat_template == other.chat_template && reasoning_format == other.reasoning_format && is_model_asset == other.is_model_asset && use_progress_callback == other.use_progress_callback && n_ctx == other.n_ctx && n_batch == other.n_batch && n_ubatch == other.n_ubatch && n_threads == other.n_threads && n_gpu_layers == other.n_gpu_layers && no_gpu_devices == other.no_gpu_devices && flash_attn == other.flash_attn && cache_type_k == other.cache_type_k && cache_type_v == other.cache_type_v && use_mlock == other.use_mlock && use_mmap == other.use_mmap && vocab_only == other.vocab_only && lora == other.lora && lora_scaled == other.lora_scaled && lora_list == other.lora_list && rope_freq_base == other.rope_freq_base && rope_freq_scale == other.rope_freq_scale && pooling_type == other.pooling_type && embedding == other.embedding && embd_normalize == other.embd_normalize;
  }
};

template <typename T>
struct NativeRNLlamaNativeContextParamsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.model)>(rt, value.getProperty(rt, "model"), jsInvoker),
      bridging::fromJs<decltype(types.chat_template)>(rt, value.getProperty(rt, "chat_template"), jsInvoker),
      bridging::fromJs<decltype(types.reasoning_format)>(rt, value.getProperty(rt, "reasoning_format"), jsInvoker),
      bridging::fromJs<decltype(types.is_model_asset)>(rt, value.getProperty(rt, "is_model_asset"), jsInvoker),
      bridging::fromJs<decltype(types.use_progress_callback)>(rt, value.getProperty(rt, "use_progress_callback"), jsInvoker),
      bridging::fromJs<decltype(types.n_ctx)>(rt, value.getProperty(rt, "n_ctx"), jsInvoker),
      bridging::fromJs<decltype(types.n_batch)>(rt, value.getProperty(rt, "n_batch"), jsInvoker),
      bridging::fromJs<decltype(types.n_ubatch)>(rt, value.getProperty(rt, "n_ubatch"), jsInvoker),
      bridging::fromJs<decltype(types.n_threads)>(rt, value.getProperty(rt, "n_threads"), jsInvoker),
      bridging::fromJs<decltype(types.n_gpu_layers)>(rt, value.getProperty(rt, "n_gpu_layers"), jsInvoker),
      bridging::fromJs<decltype(types.no_gpu_devices)>(rt, value.getProperty(rt, "no_gpu_devices"), jsInvoker),
      bridging::fromJs<decltype(types.flash_attn)>(rt, value.getProperty(rt, "flash_attn"), jsInvoker),
      bridging::fromJs<decltype(types.cache_type_k)>(rt, value.getProperty(rt, "cache_type_k"), jsInvoker),
      bridging::fromJs<decltype(types.cache_type_v)>(rt, value.getProperty(rt, "cache_type_v"), jsInvoker),
      bridging::fromJs<decltype(types.use_mlock)>(rt, value.getProperty(rt, "use_mlock"), jsInvoker),
      bridging::fromJs<decltype(types.use_mmap)>(rt, value.getProperty(rt, "use_mmap"), jsInvoker),
      bridging::fromJs<decltype(types.vocab_only)>(rt, value.getProperty(rt, "vocab_only"), jsInvoker),
      bridging::fromJs<decltype(types.lora)>(rt, value.getProperty(rt, "lora"), jsInvoker),
      bridging::fromJs<decltype(types.lora_scaled)>(rt, value.getProperty(rt, "lora_scaled"), jsInvoker),
      bridging::fromJs<decltype(types.lora_list)>(rt, value.getProperty(rt, "lora_list"), jsInvoker),
      bridging::fromJs<decltype(types.rope_freq_base)>(rt, value.getProperty(rt, "rope_freq_base"), jsInvoker),
      bridging::fromJs<decltype(types.rope_freq_scale)>(rt, value.getProperty(rt, "rope_freq_scale"), jsInvoker),
      bridging::fromJs<decltype(types.pooling_type)>(rt, value.getProperty(rt, "pooling_type"), jsInvoker),
      bridging::fromJs<decltype(types.embedding)>(rt, value.getProperty(rt, "embedding"), jsInvoker),
      bridging::fromJs<decltype(types.embd_normalize)>(rt, value.getProperty(rt, "embd_normalize"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String modelToJs(jsi::Runtime &rt, decltype(types.model) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String chat_templateToJs(jsi::Runtime &rt, decltype(types.chat_template) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String reasoning_formatToJs(jsi::Runtime &rt, decltype(types.reasoning_format) value) {
    return bridging::toJs(rt, value);
  }

  static bool is_model_assetToJs(jsi::Runtime &rt, decltype(types.is_model_asset) value) {
    return bridging::toJs(rt, value);
  }

  static bool use_progress_callbackToJs(jsi::Runtime &rt, decltype(types.use_progress_callback) value) {
    return bridging::toJs(rt, value);
  }

  static double n_ctxToJs(jsi::Runtime &rt, decltype(types.n_ctx) value) {
    return bridging::toJs(rt, value);
  }

  static double n_batchToJs(jsi::Runtime &rt, decltype(types.n_batch) value) {
    return bridging::toJs(rt, value);
  }

  static double n_ubatchToJs(jsi::Runtime &rt, decltype(types.n_ubatch) value) {
    return bridging::toJs(rt, value);
  }

  static double n_threadsToJs(jsi::Runtime &rt, decltype(types.n_threads) value) {
    return bridging::toJs(rt, value);
  }

  static double n_gpu_layersToJs(jsi::Runtime &rt, decltype(types.n_gpu_layers) value) {
    return bridging::toJs(rt, value);
  }

  static bool no_gpu_devicesToJs(jsi::Runtime &rt, decltype(types.no_gpu_devices) value) {
    return bridging::toJs(rt, value);
  }

  static bool flash_attnToJs(jsi::Runtime &rt, decltype(types.flash_attn) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cache_type_kToJs(jsi::Runtime &rt, decltype(types.cache_type_k) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cache_type_vToJs(jsi::Runtime &rt, decltype(types.cache_type_v) value) {
    return bridging::toJs(rt, value);
  }

  static bool use_mlockToJs(jsi::Runtime &rt, decltype(types.use_mlock) value) {
    return bridging::toJs(rt, value);
  }

  static bool use_mmapToJs(jsi::Runtime &rt, decltype(types.use_mmap) value) {
    return bridging::toJs(rt, value);
  }

  static bool vocab_onlyToJs(jsi::Runtime &rt, decltype(types.vocab_only) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String loraToJs(jsi::Runtime &rt, decltype(types.lora) value) {
    return bridging::toJs(rt, value);
  }

  static double lora_scaledToJs(jsi::Runtime &rt, decltype(types.lora_scaled) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array lora_listToJs(jsi::Runtime &rt, decltype(types.lora_list) value) {
    return bridging::toJs(rt, value);
  }

  static double rope_freq_baseToJs(jsi::Runtime &rt, decltype(types.rope_freq_base) value) {
    return bridging::toJs(rt, value);
  }

  static double rope_freq_scaleToJs(jsi::Runtime &rt, decltype(types.rope_freq_scale) value) {
    return bridging::toJs(rt, value);
  }

  static double pooling_typeToJs(jsi::Runtime &rt, decltype(types.pooling_type) value) {
    return bridging::toJs(rt, value);
  }

  static bool embeddingToJs(jsi::Runtime &rt, decltype(types.embedding) value) {
    return bridging::toJs(rt, value);
  }

  static double embd_normalizeToJs(jsi::Runtime &rt, decltype(types.embd_normalize) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "model", bridging::toJs(rt, value.model, jsInvoker));
    if (value.chat_template) {
      result.setProperty(rt, "chat_template", bridging::toJs(rt, value.chat_template.value(), jsInvoker));
    }
    if (value.reasoning_format) {
      result.setProperty(rt, "reasoning_format", bridging::toJs(rt, value.reasoning_format.value(), jsInvoker));
    }
    if (value.is_model_asset) {
      result.setProperty(rt, "is_model_asset", bridging::toJs(rt, value.is_model_asset.value(), jsInvoker));
    }
    if (value.use_progress_callback) {
      result.setProperty(rt, "use_progress_callback", bridging::toJs(rt, value.use_progress_callback.value(), jsInvoker));
    }
    if (value.n_ctx) {
      result.setProperty(rt, "n_ctx", bridging::toJs(rt, value.n_ctx.value(), jsInvoker));
    }
    if (value.n_batch) {
      result.setProperty(rt, "n_batch", bridging::toJs(rt, value.n_batch.value(), jsInvoker));
    }
    if (value.n_ubatch) {
      result.setProperty(rt, "n_ubatch", bridging::toJs(rt, value.n_ubatch.value(), jsInvoker));
    }
    if (value.n_threads) {
      result.setProperty(rt, "n_threads", bridging::toJs(rt, value.n_threads.value(), jsInvoker));
    }
    if (value.n_gpu_layers) {
      result.setProperty(rt, "n_gpu_layers", bridging::toJs(rt, value.n_gpu_layers.value(), jsInvoker));
    }
    if (value.no_gpu_devices) {
      result.setProperty(rt, "no_gpu_devices", bridging::toJs(rt, value.no_gpu_devices.value(), jsInvoker));
    }
    if (value.flash_attn) {
      result.setProperty(rt, "flash_attn", bridging::toJs(rt, value.flash_attn.value(), jsInvoker));
    }
    if (value.cache_type_k) {
      result.setProperty(rt, "cache_type_k", bridging::toJs(rt, value.cache_type_k.value(), jsInvoker));
    }
    if (value.cache_type_v) {
      result.setProperty(rt, "cache_type_v", bridging::toJs(rt, value.cache_type_v.value(), jsInvoker));
    }
    if (value.use_mlock) {
      result.setProperty(rt, "use_mlock", bridging::toJs(rt, value.use_mlock.value(), jsInvoker));
    }
    if (value.use_mmap) {
      result.setProperty(rt, "use_mmap", bridging::toJs(rt, value.use_mmap.value(), jsInvoker));
    }
    if (value.vocab_only) {
      result.setProperty(rt, "vocab_only", bridging::toJs(rt, value.vocab_only.value(), jsInvoker));
    }
    if (value.lora) {
      result.setProperty(rt, "lora", bridging::toJs(rt, value.lora.value(), jsInvoker));
    }
    if (value.lora_scaled) {
      result.setProperty(rt, "lora_scaled", bridging::toJs(rt, value.lora_scaled.value(), jsInvoker));
    }
    if (value.lora_list) {
      result.setProperty(rt, "lora_list", bridging::toJs(rt, value.lora_list.value(), jsInvoker));
    }
    if (value.rope_freq_base) {
      result.setProperty(rt, "rope_freq_base", bridging::toJs(rt, value.rope_freq_base.value(), jsInvoker));
    }
    if (value.rope_freq_scale) {
      result.setProperty(rt, "rope_freq_scale", bridging::toJs(rt, value.rope_freq_scale.value(), jsInvoker));
    }
    if (value.pooling_type) {
      result.setProperty(rt, "pooling_type", bridging::toJs(rt, value.pooling_type.value(), jsInvoker));
    }
    if (value.embedding) {
      result.setProperty(rt, "embedding", bridging::toJs(rt, value.embedding.value(), jsInvoker));
    }
    if (value.embd_normalize) {
      result.setProperty(rt, "embd_normalize", bridging::toJs(rt, value.embd_normalize.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeEmbeddingParams

template <typename P0>
struct NativeRNLlamaNativeEmbeddingParams {
  P0 embd_normalize;
  bool operator==(const NativeRNLlamaNativeEmbeddingParams &other) const {
    return embd_normalize == other.embd_normalize;
  }
};

template <typename T>
struct NativeRNLlamaNativeEmbeddingParamsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.embd_normalize)>(rt, value.getProperty(rt, "embd_normalize"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double embd_normalizeToJs(jsi::Runtime &rt, decltype(types.embd_normalize) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.embd_normalize) {
      result.setProperty(rt, "embd_normalize", bridging::toJs(rt, value.embd_normalize.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeEmbeddingResult

template <typename P0>
struct NativeRNLlamaNativeEmbeddingResult {
  P0 embedding;
  bool operator==(const NativeRNLlamaNativeEmbeddingResult &other) const {
    return embedding == other.embedding;
  }
};

template <typename T>
struct NativeRNLlamaNativeEmbeddingResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.embedding)>(rt, value.getProperty(rt, "embedding"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array embeddingToJs(jsi::Runtime &rt, decltype(types.embedding) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "embedding", bridging::toJs(rt, value.embedding, jsInvoker));
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeLlamaContext

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeRNLlamaNativeLlamaContext {
  P0 contextId;
  P1 model;
  P2 androidLib;
  P3 gpu;
  P4 reasonNoGPU;
  bool operator==(const NativeRNLlamaNativeLlamaContext &other) const {
    return contextId == other.contextId && model == other.model && androidLib == other.androidLib && gpu == other.gpu && reasonNoGPU == other.reasonNoGPU;
  }
};

template <typename T>
struct NativeRNLlamaNativeLlamaContextBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.contextId)>(rt, value.getProperty(rt, "contextId"), jsInvoker),
      bridging::fromJs<decltype(types.model)>(rt, value.getProperty(rt, "model"), jsInvoker),
      bridging::fromJs<decltype(types.androidLib)>(rt, value.getProperty(rt, "androidLib"), jsInvoker),
      bridging::fromJs<decltype(types.gpu)>(rt, value.getProperty(rt, "gpu"), jsInvoker),
      bridging::fromJs<decltype(types.reasonNoGPU)>(rt, value.getProperty(rt, "reasonNoGPU"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double contextIdToJs(jsi::Runtime &rt, decltype(types.contextId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object modelToJs(jsi::Runtime &rt, decltype(types.model) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String androidLibToJs(jsi::Runtime &rt, decltype(types.androidLib) value) {
    return bridging::toJs(rt, value);
  }

  static bool gpuToJs(jsi::Runtime &rt, decltype(types.gpu) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String reasonNoGPUToJs(jsi::Runtime &rt, decltype(types.reasonNoGPU) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "contextId", bridging::toJs(rt, value.contextId, jsInvoker));
    result.setProperty(rt, "model", bridging::toJs(rt, value.model, jsInvoker));
    if (value.androidLib) {
      result.setProperty(rt, "androidLib", bridging::toJs(rt, value.androidLib.value(), jsInvoker));
    }
    result.setProperty(rt, "gpu", bridging::toJs(rt, value.gpu, jsInvoker));
    result.setProperty(rt, "reasonNoGPU", bridging::toJs(rt, value.reasonNoGPU, jsInvoker));
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeSessionLoadResult

template <typename P0, typename P1>
struct NativeRNLlamaNativeSessionLoadResult {
  P0 tokens_loaded;
  P1 prompt;
  bool operator==(const NativeRNLlamaNativeSessionLoadResult &other) const {
    return tokens_loaded == other.tokens_loaded && prompt == other.prompt;
  }
};

template <typename T>
struct NativeRNLlamaNativeSessionLoadResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.tokens_loaded)>(rt, value.getProperty(rt, "tokens_loaded"), jsInvoker),
      bridging::fromJs<decltype(types.prompt)>(rt, value.getProperty(rt, "prompt"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double tokens_loadedToJs(jsi::Runtime &rt, decltype(types.tokens_loaded) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String promptToJs(jsi::Runtime &rt, decltype(types.prompt) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "tokens_loaded", bridging::toJs(rt, value.tokens_loaded, jsInvoker));
    result.setProperty(rt, "prompt", bridging::toJs(rt, value.prompt, jsInvoker));
    return result;
  }
};



#pragma mark - NativeRNLlamaNativeTokenizeResult

template <typename P0>
struct NativeRNLlamaNativeTokenizeResult {
  P0 tokens;
  bool operator==(const NativeRNLlamaNativeTokenizeResult &other) const {
    return tokens == other.tokens;
  }
};

template <typename T>
struct NativeRNLlamaNativeTokenizeResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.tokens)>(rt, value.getProperty(rt, "tokens"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array tokensToJs(jsi::Runtime &rt, decltype(types.tokens) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "tokens", bridging::toJs(rt, value.tokens, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeRNLlamaCxxSpecJSI : public TurboModule {
protected:
  NativeRNLlamaCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value toggleNativeLog(jsi::Runtime &rt, bool enabled) = 0;
  virtual jsi::Value setContextLimit(jsi::Runtime &rt, double limit) = 0;
  virtual jsi::Value modelInfo(jsi::Runtime &rt, jsi::String path, std::optional<jsi::Array> skip) = 0;
  virtual jsi::Value initContext(jsi::Runtime &rt, double contextId, jsi::Object params) = 0;
  virtual jsi::Value getFormattedChat(jsi::Runtime &rt, double contextId, jsi::String messages, std::optional<jsi::String> chatTemplate, std::optional<jsi::Object> params) = 0;
  virtual jsi::Value loadSession(jsi::Runtime &rt, double contextId, jsi::String filepath) = 0;
  virtual jsi::Value saveSession(jsi::Runtime &rt, double contextId, jsi::String filepath, double size) = 0;
  virtual jsi::Value completion(jsi::Runtime &rt, double contextId, jsi::Object params) = 0;
  virtual jsi::Value stopCompletion(jsi::Runtime &rt, double contextId) = 0;
  virtual jsi::Value tokenize(jsi::Runtime &rt, double contextId, jsi::String text) = 0;
  virtual jsi::Value detokenize(jsi::Runtime &rt, double contextId, jsi::Array tokens) = 0;
  virtual jsi::Value embedding(jsi::Runtime &rt, double contextId, jsi::String text, jsi::Object params) = 0;
  virtual jsi::Value bench(jsi::Runtime &rt, double contextId, double pp, double tg, double pl, double nr) = 0;
  virtual jsi::Value applyLoraAdapters(jsi::Runtime &rt, double contextId, jsi::Array loraAdapters) = 0;
  virtual jsi::Value removeLoraAdapters(jsi::Runtime &rt, double contextId) = 0;
  virtual jsi::Value getLoadedLoraAdapters(jsi::Runtime &rt, double contextId) = 0;
  virtual jsi::Value releaseContext(jsi::Runtime &rt, double contextId) = 0;
  virtual jsi::Value releaseAllContexts(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNLlamaCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "RNLlama";

protected:
  NativeRNLlamaCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNLlamaCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeRNLlamaCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNLlamaCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value toggleNativeLog(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::toggleNativeLog) == 2,
          "Expected toggleNativeLog(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::toggleNativeLog, jsInvoker_, instance_, std::move(enabled));
    }
    jsi::Value setContextLimit(jsi::Runtime &rt, double limit) override {
      static_assert(
          bridging::getParameterCount(&T::setContextLimit) == 2,
          "Expected setContextLimit(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setContextLimit, jsInvoker_, instance_, std::move(limit));
    }
    jsi::Value modelInfo(jsi::Runtime &rt, jsi::String path, std::optional<jsi::Array> skip) override {
      static_assert(
          bridging::getParameterCount(&T::modelInfo) == 3,
          "Expected modelInfo(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::modelInfo, jsInvoker_, instance_, std::move(path), std::move(skip));
    }
    jsi::Value initContext(jsi::Runtime &rt, double contextId, jsi::Object params) override {
      static_assert(
          bridging::getParameterCount(&T::initContext) == 3,
          "Expected initContext(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::initContext, jsInvoker_, instance_, std::move(contextId), std::move(params));
    }
    jsi::Value getFormattedChat(jsi::Runtime &rt, double contextId, jsi::String messages, std::optional<jsi::String> chatTemplate, std::optional<jsi::Object> params) override {
      static_assert(
          bridging::getParameterCount(&T::getFormattedChat) == 5,
          "Expected getFormattedChat(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getFormattedChat, jsInvoker_, instance_, std::move(contextId), std::move(messages), std::move(chatTemplate), std::move(params));
    }
    jsi::Value loadSession(jsi::Runtime &rt, double contextId, jsi::String filepath) override {
      static_assert(
          bridging::getParameterCount(&T::loadSession) == 3,
          "Expected loadSession(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::loadSession, jsInvoker_, instance_, std::move(contextId), std::move(filepath));
    }
    jsi::Value saveSession(jsi::Runtime &rt, double contextId, jsi::String filepath, double size) override {
      static_assert(
          bridging::getParameterCount(&T::saveSession) == 4,
          "Expected saveSession(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::saveSession, jsInvoker_, instance_, std::move(contextId), std::move(filepath), std::move(size));
    }
    jsi::Value completion(jsi::Runtime &rt, double contextId, jsi::Object params) override {
      static_assert(
          bridging::getParameterCount(&T::completion) == 3,
          "Expected completion(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::completion, jsInvoker_, instance_, std::move(contextId), std::move(params));
    }
    jsi::Value stopCompletion(jsi::Runtime &rt, double contextId) override {
      static_assert(
          bridging::getParameterCount(&T::stopCompletion) == 2,
          "Expected stopCompletion(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::stopCompletion, jsInvoker_, instance_, std::move(contextId));
    }
    jsi::Value tokenize(jsi::Runtime &rt, double contextId, jsi::String text) override {
      static_assert(
          bridging::getParameterCount(&T::tokenize) == 3,
          "Expected tokenize(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::tokenize, jsInvoker_, instance_, std::move(contextId), std::move(text));
    }
    jsi::Value detokenize(jsi::Runtime &rt, double contextId, jsi::Array tokens) override {
      static_assert(
          bridging::getParameterCount(&T::detokenize) == 3,
          "Expected detokenize(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::detokenize, jsInvoker_, instance_, std::move(contextId), std::move(tokens));
    }
    jsi::Value embedding(jsi::Runtime &rt, double contextId, jsi::String text, jsi::Object params) override {
      static_assert(
          bridging::getParameterCount(&T::embedding) == 4,
          "Expected embedding(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::embedding, jsInvoker_, instance_, std::move(contextId), std::move(text), std::move(params));
    }
    jsi::Value bench(jsi::Runtime &rt, double contextId, double pp, double tg, double pl, double nr) override {
      static_assert(
          bridging::getParameterCount(&T::bench) == 6,
          "Expected bench(...) to have 6 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::bench, jsInvoker_, instance_, std::move(contextId), std::move(pp), std::move(tg), std::move(pl), std::move(nr));
    }
    jsi::Value applyLoraAdapters(jsi::Runtime &rt, double contextId, jsi::Array loraAdapters) override {
      static_assert(
          bridging::getParameterCount(&T::applyLoraAdapters) == 3,
          "Expected applyLoraAdapters(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::applyLoraAdapters, jsInvoker_, instance_, std::move(contextId), std::move(loraAdapters));
    }
    jsi::Value removeLoraAdapters(jsi::Runtime &rt, double contextId) override {
      static_assert(
          bridging::getParameterCount(&T::removeLoraAdapters) == 2,
          "Expected removeLoraAdapters(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removeLoraAdapters, jsInvoker_, instance_, std::move(contextId));
    }
    jsi::Value getLoadedLoraAdapters(jsi::Runtime &rt, double contextId) override {
      static_assert(
          bridging::getParameterCount(&T::getLoadedLoraAdapters) == 2,
          "Expected getLoadedLoraAdapters(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getLoadedLoraAdapters, jsInvoker_, instance_, std::move(contextId));
    }
    jsi::Value releaseContext(jsi::Runtime &rt, double contextId) override {
      static_assert(
          bridging::getParameterCount(&T::releaseContext) == 2,
          "Expected releaseContext(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::releaseContext, jsInvoker_, instance_, std::move(contextId));
    }
    jsi::Value releaseAllContexts(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::releaseAllContexts) == 1,
          "Expected releaseAllContexts(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::releaseAllContexts, jsInvoker_, instance_);
    }

  private:
    friend class NativeRNLlamaCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
