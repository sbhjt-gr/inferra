
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <vector>

namespace facebook::react {

struct MenuViewActionsAttributesStruct {
  bool destructive{false};
  bool disabled{false};
  bool hidden{false};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, MenuViewActionsAttributesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_destructive = map.find("destructive");
  if (tmp_destructive != map.end()) {
    fromRawValue(context, tmp_destructive->second, result.destructive);
  }
  auto tmp_disabled = map.find("disabled");
  if (tmp_disabled != map.end()) {
    fromRawValue(context, tmp_disabled->second, result.disabled);
  }
  auto tmp_hidden = map.find("hidden");
  if (tmp_hidden != map.end()) {
    fromRawValue(context, tmp_hidden->second, result.hidden);
  }
}

static inline std::string toString(const MenuViewActionsAttributesStruct &value) {
  return "[Object MenuViewActionsAttributesStruct]";
}

struct MenuViewActionsSubactionsAttributesStruct {
  bool destructive{false};
  bool disabled{false};
  bool hidden{false};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, MenuViewActionsSubactionsAttributesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_destructive = map.find("destructive");
  if (tmp_destructive != map.end()) {
    fromRawValue(context, tmp_destructive->second, result.destructive);
  }
  auto tmp_disabled = map.find("disabled");
  if (tmp_disabled != map.end()) {
    fromRawValue(context, tmp_disabled->second, result.disabled);
  }
  auto tmp_hidden = map.find("hidden");
  if (tmp_hidden != map.end()) {
    fromRawValue(context, tmp_hidden->second, result.hidden);
  }
}

static inline std::string toString(const MenuViewActionsSubactionsAttributesStruct &value) {
  return "[Object MenuViewActionsSubactionsAttributesStruct]";
}

struct MenuViewActionsSubactionsStruct {
  std::string id{};
  std::string title{};
  int titleColor{0};
  std::string subtitle{};
  std::string state{};
  std::string image{};
  int imageColor{0};
  bool displayInline{false};
  MenuViewActionsSubactionsAttributesStruct attributes{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, MenuViewActionsSubactionsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_id = map.find("id");
  if (tmp_id != map.end()) {
    fromRawValue(context, tmp_id->second, result.id);
  }
  auto tmp_title = map.find("title");
  if (tmp_title != map.end()) {
    fromRawValue(context, tmp_title->second, result.title);
  }
  auto tmp_titleColor = map.find("titleColor");
  if (tmp_titleColor != map.end()) {
    fromRawValue(context, tmp_titleColor->second, result.titleColor);
  }
  auto tmp_subtitle = map.find("subtitle");
  if (tmp_subtitle != map.end()) {
    fromRawValue(context, tmp_subtitle->second, result.subtitle);
  }
  auto tmp_state = map.find("state");
  if (tmp_state != map.end()) {
    fromRawValue(context, tmp_state->second, result.state);
  }
  auto tmp_image = map.find("image");
  if (tmp_image != map.end()) {
    fromRawValue(context, tmp_image->second, result.image);
  }
  auto tmp_imageColor = map.find("imageColor");
  if (tmp_imageColor != map.end()) {
    fromRawValue(context, tmp_imageColor->second, result.imageColor);
  }
  auto tmp_displayInline = map.find("displayInline");
  if (tmp_displayInline != map.end()) {
    fromRawValue(context, tmp_displayInline->second, result.displayInline);
  }
  auto tmp_attributes = map.find("attributes");
  if (tmp_attributes != map.end()) {
    fromRawValue(context, tmp_attributes->second, result.attributes);
  }
}

static inline std::string toString(const MenuViewActionsSubactionsStruct &value) {
  return "[Object MenuViewActionsSubactionsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<MenuViewActionsSubactionsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    MenuViewActionsSubactionsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct MenuViewActionsStruct {
  std::string id{};
  std::string title{};
  int titleColor{0};
  std::string subtitle{};
  std::string state{};
  std::string image{};
  int imageColor{0};
  bool displayInline{false};
  MenuViewActionsAttributesStruct attributes{};
  std::vector<MenuViewActionsSubactionsStruct> subactions{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, MenuViewActionsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_id = map.find("id");
  if (tmp_id != map.end()) {
    fromRawValue(context, tmp_id->second, result.id);
  }
  auto tmp_title = map.find("title");
  if (tmp_title != map.end()) {
    fromRawValue(context, tmp_title->second, result.title);
  }
  auto tmp_titleColor = map.find("titleColor");
  if (tmp_titleColor != map.end()) {
    fromRawValue(context, tmp_titleColor->second, result.titleColor);
  }
  auto tmp_subtitle = map.find("subtitle");
  if (tmp_subtitle != map.end()) {
    fromRawValue(context, tmp_subtitle->second, result.subtitle);
  }
  auto tmp_state = map.find("state");
  if (tmp_state != map.end()) {
    fromRawValue(context, tmp_state->second, result.state);
  }
  auto tmp_image = map.find("image");
  if (tmp_image != map.end()) {
    fromRawValue(context, tmp_image->second, result.image);
  }
  auto tmp_imageColor = map.find("imageColor");
  if (tmp_imageColor != map.end()) {
    fromRawValue(context, tmp_imageColor->second, result.imageColor);
  }
  auto tmp_displayInline = map.find("displayInline");
  if (tmp_displayInline != map.end()) {
    fromRawValue(context, tmp_displayInline->second, result.displayInline);
  }
  auto tmp_attributes = map.find("attributes");
  if (tmp_attributes != map.end()) {
    fromRawValue(context, tmp_attributes->second, result.attributes);
  }
  auto tmp_subactions = map.find("subactions");
  if (tmp_subactions != map.end()) {
    fromRawValue(context, tmp_subactions->second, result.subactions);
  }
}

static inline std::string toString(const MenuViewActionsStruct &value) {
  return "[Object MenuViewActionsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<MenuViewActionsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    MenuViewActionsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct MenuViewHitSlopStruct {
  int top{0};
  int bottom{0};
  int left{0};
  int right{0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, MenuViewHitSlopStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
  auto tmp_left = map.find("left");
  if (tmp_left != map.end()) {
    fromRawValue(context, tmp_left->second, result.left);
  }
  auto tmp_right = map.find("right");
  if (tmp_right != map.end()) {
    fromRawValue(context, tmp_right->second, result.right);
  }
}

static inline std::string toString(const MenuViewHitSlopStruct &value) {
  return "[Object MenuViewHitSlopStruct]";
}
class MenuViewProps final : public ViewProps {
 public:
  MenuViewProps() = default;
  MenuViewProps(const PropsParserContext& context, const MenuViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::vector<MenuViewActionsStruct> actions{};
  std::string actionsHash{};
  std::string title{};
  std::string themeVariant{};
  bool shouldOpenOnLongPress{false};
  MenuViewHitSlopStruct hitSlop{};
};

} // namespace facebook::react
